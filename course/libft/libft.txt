ğŸ“˜ Libft Quick Guide
=====================

ğŸ”¤ Character checks
---------------------
isalpha(c)       â†’ Verifica se c Ã© uma letra [A-Za-z]
isdigit(c)       â†’ Verifica se c Ã© um dÃ­gito [0-9]
isalnum(c)       â†’ Verifica se c Ã© alfanumÃ©rico [A-Za-z0-9]
isascii(c)       â†’ Verifica se c Ã© um caractere ASCII (0â€“127)
isprint(c)       â†’ Verifica se c Ã© imprimÃ­vel (32â€“126)

ğŸ”¡ Character case conversion
---------------------
toupper(c)       â†’ Converte para maiÃºscula (se aplicÃ¡vel)
tolower(c)       â†’ Converte para minÃºscula (se aplicÃ¡vel)

ğŸ”  Strings
---------------------
strlen(s)        â†’ Retorna tamanho da string (sem '\0')
strchr(s, c)     â†’ Retorna ponteiro para primeira ocorrÃªncia de c em s
strrchr(s, c)    â†’ Retorna ponteiro para Ãºltima ocorrÃªncia de c em s
strncmp(s1,s2,n) â†’ Compara atÃ© n caracteres de s1 e s2
strnstr(h,n,n)   â†’ Procura substring 'n' dentro de 'h' nos primeiros n bytes
strlcpy(dst,src,n) â†’ Copia src para dst com limite de n bytes
strlcat(dst,src,n) â†’ Concatena src em dst com limite de tamanho total n

ğŸ§  Memory
---------------------
memset(s, c, n)  â†’ Preenche os n bytes de s com c
bzero(s, n)      â†’ Zera n bytes de s
memcpy(d, s, n)  â†’ Copia n bytes de s para d (sem sobreposiÃ§Ã£o)
memmove(d,s,n)   â†’ Copia n bytes de s para d (com suporte a sobreposiÃ§Ã£o)
memchr(s,c,n)    â†’ Procura c em s nos n primeiros bytes
memcmp(s1,s2,n)  â†’ Compara n bytes de s1 e s2

ğŸ”¢ ConversÃµes
---------------------
atoi(s)          â†’ Converte string para int
calloc(n, size)  â†’ Aloca memÃ³ria para n elementos de size bytes e zera
strdup(s)        â†’ Duplica string (aloca e copia)

ğŸ”§ String utils
---------------------
ft_substr(s, start, len) â†’ Retorna substring de s
ft_strjoin(s1, s2)       â†’ Junta duas strings
ft_strtrim(s, set)       â†’ Remove chars de set do inÃ­cio e fim de s
ft_split(s, c)           â†’ Divide string em array usando c como delimitador
ft_itoa(n)               â†’ Converte int em string
ft_strmapi(s, f)         â†’ Aplica f(i, c) a cada char de s (com retorno)
ft_striteri(s, f)        â†’ Aplica f(i, &c) a cada char de s (modifica in-place)

ğŸ“¤ Escrita em file descriptor
---------------------
ft_putchar_fd(c, fd)     â†’ Escreve caractere c no fd
ft_putstr_fd(s, fd)      â†’ Escreve string s no fd
ft_putendl_fd(s, fd)     â†’ Escreve string s seguida de '\n' no fd
ft_putnbr_fd(n, fd)      â†’ Escreve nÃºmero inteiro n no fd

ğŸŒ² Lista encadeada (t_list)
---------------------
ft_lstnew(content)         â†’ Cria novo nÃ³ com content
ft_lstadd_front(&lst, new) â†’ Adiciona nÃ³ no inÃ­cio da lista
ft_lstsize(lst)            â†’ Retorna nÃºmero de nÃ³s
ft_lstlast(lst)            â†’ Retorna Ãºltimo nÃ³
ft_lstadd_back(&lst, new)  â†’ Adiciona nÃ³ ao final
ft_lstdelone(node, del)    â†’ Libera um nÃ³ usando a funÃ§Ã£o del()
ft_lstclear(&lst, del)     â†’ Libera todos os nÃ³s da lista, usando a funÃ§Ã£o del() para liberar o conteÃºdo. O ponteiro da lista vira NULL.
ft_lstiter(lst, f)         â†’ Aplica a funÃ§Ã£o f() em cada elemento da lista (no conteÃºdo de cada nÃ³).
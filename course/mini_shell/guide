Functional Requirements
Shell Behavior

Display a prompt when waiting for user input.

Use GNU Readline library for input with working command history.

Correctly parse and execute commands using the system environment and PATH.

Support relative and absolute paths to executables.

Implement a single global variable only to store received signals (signal numbers). No complex global state allowed.

Properly handle signals:

Ctrl-C should cancel the current input and display a new prompt.

Ctrl-D should exit the shell.

Ctrl-\ should be ignored.

minishell/
├── src/               # Source files (.c)
│   ├── main.c         # Entry point
│   ├── parser.c       # Parsing logic (quotes, tokens, expansions)
│   ├── executor.c     # Command execution, forks, pipes, redirections
│   ├── builtin.c      # Built-in command implementations
│   ├── signals.c      # Signal handlers
│   ├── utils.c        # Helper functions (string utils, error handling)
│   └── ...            # Other source files as needed
│
├── include/           # Header files (.h)
│   ├── minishell.h    # Main project-wide definitions and prototypes
│   ├── parser.h       # Parser function prototypes and structs
│   ├── executor.h     # Execution related prototypes
│   ├── builtin.h      # Built-in commands interface
│   ├── signals.h      # Signal handling prototypes
│   └── utils.h        # Utility function prototypes
│
├── libft/             # Your custom libft library source and headers (if allowed)
│   ├── src/
│   └── include/
│
├── obj/               # Object files (generated by Makefile)
│
├── Makefile           # Build instructions
├── README.md          # Project documentation and build guide
└── .gitignore         # To exclude obj/, executables, etc. from git


Command Parsing
Handle quoting rules:

Single quotes '...' prevent interpretation of metacharacters.

Double quotes "..." prevent interpretation except for $ (for variable expansion).

Implement environment variable expansion:

$VARIABLE expands to its value.

$? expands to the exit status of the last command.

Do not interpret unsupported special characters (e.g., backslash \ or semicolon ;).

Redirections and Pipes
Implement input/output redirection:

< for input redirection.

> for output redirection (overwrite).

>> for output redirection (append).

<< (here-document) reads until a delimiter line is reached; input from here-doc should not be added to history.

Support piping (|):

Connect the output of one command to the input of the next.

Support multiple chained pipes.

Built-in Commands
Implement these built-ins with the specified behaviors:

echo [-n] - print arguments; -n suppresses the trailing newline.

cd - change directory using relative or absolute paths.

pwd - print current working directory; no options.

export - add or modify environment variables; no options.

unset - remove environment variables; no options.

env - display environment variables; no arguments.

exit - exit the shell; no options.




Allowed External Functions

# 🧾 C Library Function Guide (Allowed Functions)

This guide is for quick consulting during projects like `minishell`, where only a limited set of external functions is allowed. Functions are grouped by category, each with a short usage explanation and context.

---

## 📥 Input and Output

| Function | Description & Usage |
|----------|---------------------|

| `readline(prompt)` | Prompts the user with `prompt` and reads a full line from stdin, supporting **line editing**, **arrow key history**, and **auto-completion** (if configured). 
    Crucial for interactive shells. Returns a `char *` (must `free` it after use). Example: `char *line = readline("minishell$ ");` |

| `rl_clear_history()` | Clears the readline history list. Useful when resetting the shell or before exiting to free internal memory used by readline's history buffer. |

| `rl_on_new_line()` | Tells the readline library that you're starting a new line (used after external output interrupts the prompt). Should be followed by `rl_redisplay()` to refresh the input line. |

| `rl_replace_line(text, clear_undo)` | Replaces the entire current input buffer with `text`. If `clear_undo` is non-zero, it clears the undo stack. 
    Useful for things like autocompletion or suggestions. Example: `rl_replace_line("ls -la", 1); rl_redisplay();` |

| `rl_redisplay()` | Reprints the current line buffer to the terminal. Required if you manipulate the input line (e.g., with `printf`) so the prompt and input reappear properly. |

| `add_history(line)` | Adds `line` to the history buffer, making it accessible via arrow keys. Should be called after confirming the input is valid and not empty. Does **not** duplicate the string, so pass a non-const copy. |

| `printf(format, ...)` | Standard formatted output function. Safer and more flexible than `write`, 
    supporting format specifiers (`%s`, `%d`, etc.). Buffering behavior may delay output in pipes unless flushed with `fflush(stdout);`. |

| `write(fd, buf, count)` | Low-level function to write `count` bytes from `buf` to file descriptor `fd`. 
    Returns the number of bytes written or -1 on error. Used for raw output like writing to pipes or directly to `STDERR_FILENO`. Example: `write(1, "hello\n", 6);` |


---

## 🧠 Memory Management

| Function | Description & Usage |
|----------|---------------------|
| `malloc(size)` | Allocates `size` bytes of memory. Check result for `NULL`. |
| `free(ptr)` | Frees memory allocated by `malloc`. Always match `malloc` with `free`. |

---

## 📄 File Operations

| Function | Description & Usage |
|----------|---------------------|
| `access(path, mode)` | Checks file permissions (`R_OK`, `W_OK`, `X_OK`, `F_OK`). Use to validate executables. |
| `open(path, flags[, mode])` | Opens a file, returns fd. Use `O_RDONLY`, `O_CREAT`, etc. |
| `read(fd, buf, count)` | Reads bytes from file descriptor into buffer. |
| `close(fd)` | Closes file descriptor. Always close unused fds to prevent leaks. |
| `unlink(path)` | Deletes a file (like `rm`). Use for redirection or temporary file cleanup. |
| `stat(path, *buf)` | Gets info about a file (follows symlinks). |
| `lstat(path, *buf)` | Like `stat`, but doesn’t follow symlinks. |
| `fstat(fd, *buf)` | Like `stat`, but uses open fd. |

---

## 🧬 Process Control

| Function | Description & Usage |
|----------|---------------------|
| `fork()` | Creates a new process (child). Returns 0 to child, PID to parent. |
| `wait(&status)` | Waits for any child to finish. |
| `waitpid(pid, &status, options)` | Waits for a specific child (or any with `-1`). |
| `wait3(&status, options, &rusage)` | Waits with resource usage info (BSD). |
| `wait4(pid, &status, options, &rusage)` | Like `waitpid`, but includes `rusage`. |
| `execve(path, argv, envp)` | Executes a program. Replaces current process image. |
| `kill(pid, sig)` | Sends signal `sig` to process `pid`. Use to send `SIGINT`, `SIGTERM`, etc. |
| `exit(status)` | Terminates current process with exit code. |

---

## ⚠️ Signal Handling

| Function | Description & Usage |
|----------|---------------------|
| `signal(sig, handler)` | Sets function as signal handler. Simple but not always safe. |
| `sigaction(sig, &new, &old)` | More robust way to handle signals. Use for `SIGINT`, `SIGQUIT`, etc. |
| `sigemptyset(set)` | Initializes signal set to be empty. |
| `sigaddset(set, sig)` | Adds a signal to a signal set. Useful for blocking/unblocking signals. |

---

## 📁 Directory Operations

| Function | Description & Usage |
|----------|---------------------|
| `opendir(path)` | Opens a directory stream. |
| `readdir(dir)` | Reads next entry in directory (returns `struct dirent *`). |
| `closedir(dir)` | Closes directory stream. Always close after use. |

---

## 💻 Terminal and Environment

| Function | Description & Usage |
|----------|---------------------|
| `isatty(fd)` | Checks if fd refers to a terminal. Use for interactive shell detection. |
| `ttyname(fd)` | Returns terminal name for fd. |
| `ttyslot()` | Returns terminal index in `/etc/utmp`. |
| `ioctl(fd, request, ...)` | General I/O control. Can query terminal size, etc. |
| `getcwd(buf, size)` | Gets current working directory. Use for `pwd` command. |
| `chdir(path)` | Changes the working directory. |
| `getenv(name)` | Returns environment variable value (e.g., `getenv("HOME")`). |
| `tcsetattr(fd, optional_actions, *termios_p)` | Sets terminal attributes. |
| `tcgetattr(fd, *termios_p)` | Gets current terminal attributes. |

---

## 📟 Terminal Capabilities (Termcap)

| Function | Description & Usage |
|----------|---------------------|
| `tgetent(bp, termtype)` | Loads terminal capabilities. |
| `tgetflag(id)` | Checks if terminal supports a boolean capability. |
| `tgetnum(id)` | Gets numeric terminal capability. |
| `tgetstr(id, &area)` | Gets string capability (e.g., clear screen). |
| `tgoto(cap, col, row)` | Builds cursor movement string. |
| `tputs(str, affcnt, putc_fn)` | Outputs terminal string with padding. |

---

## 🧯 Error Reporting

| Function | Description & Usage |
|----------|---------------------|
| `strerror(errno)` | Returns human-readable error string for errno. |
| `perror(prefix)` | Prints descriptive error to stderr with optional prefix. |

---

## 🔀 Duplication and Pipes

| Function | Description & Usage |
|----------|---------------------|
| `dup(oldfd)` | Duplicates `oldfd` to lowest available fd. |
| `dup2(oldfd, newfd)` | Duplicates `oldfd` to exactly `newfd`. Useful for redirections. |
| `pipe(int fd[2])` | Creates a unidirectional pipe (`fd[0]` = read, `fd[1]` = write). |

---

## 📚 Notes
- Use `man <function>` in your terminal for detailed documentation.
- Always check return values for errors (e.g., `NULL`, `-1`).
- Useful headers:
  - `<unistd.h>`: `fork`, `pipe`, `dup`, `read`, `write`, etc.
  - `<fcntl.h>`: `open` flags.
  - `<signal.h>`: signal handling.
  - `<termios.h>`: terminal control.
  - `<dirent.h>`: directory operations.
  - `<sys/types.h>`, `<sys/wait.h>`, `<sys/stat.h>`, `<stdlib.h>`, `<stdio.h>`, `<string.h>`.



Current Implementation Analysis
What you've done well:

Basic tokenization structure with separate handlers for different token types
Quote handling for both single and double quotes
Whitespace skipping logic
Null termination of token array

Logical Issues to Address
1. Incomplete Tokenization
Missing Token Types:

No handling for operators (|, <, >, >>, <<)
No recognition of special characters that should be separate tokens
Current logic only handles: words, single quotes, double quotes

Logic Gap:
Your tokenizer needs to recognize when it encounters operators and treat them as separate tokens, not part of words.
2. Token Boundary Logic Flaw
In word_token():
You stop at quotes, but quotes might be embedded within words (like file'name or file"name). You need to decide: are quotes always token separators, or can they be part of words?
Decision needed:

Should echo hello"world" be 2 tokens or 3 tokens?
Shell typically treats it as 2: echo and hello"world"

3. Quote Content Extraction Issue
Current logic:

You skip the opening quote with prompt + 1
You find the closing quote
You extract content between quotes

Missing logic:

After extracting quoted content, you need to handle what comes after the closing quote
A word like "hello"world should become one token: helloworld

4. Error Handling Logic Gap
Current approach:

Return -1 on errors
Free tokens on failure

Missing logic:

No recovery mechanism
No specific error reporting (syntax error vs memory error)
Partial cleanup might leak memory

5. Memory Management Logic
Current issue:

Fixed allocation of 1024 pointers regardless of actual need
No dynamic resizing if input exceeds 1024 tokens

Better logic:

Dynamic allocation based on token count estimation
Or implement realloc-based growing array

Next Phase Logic Considerations
Token Type Classification
You'll need to classify tokens as:

WORD (regular text)
PIPE (|)
REDIRECT_IN (<)
REDIRECT_OUT (>)
REDIRECT_APPEND (>>)
HERE_DOC (<<)
QUOTED_STRING (content from quotes)

State Machine Approach
Consider implementing a state machine:

STATE_NORMAL - parsing regular characters
STATE_IN_SINGLE_QUOTE - inside single quotes
STATE_IN_DOUBLE_QUOTE - inside double quotes
STATE_OPERATOR - parsing multi-character operators

Operator Recognition Logic
You need lookahead logic:

When you see >, check if next character is also >
When you see <, check if next character is also <
This determines if it's a single or double-character operator

#### -----------------> Library Test install libcriterion-dev
To implement an HTTP server in C++98 as described, without code, here's a detailed, micro-level breakdown of the steps to help you understand the project structure and move forward step-by-step.

🚦 PHASE 1: Understand the Goal
Your goal is to implement a fully working HTTP/1.0+ web server in C++98 that:

Accepts multiple clients.

Handles GET, POST, and DELETE.

Uses non-blocking I/O (poll/select/epoll/kqueue).

Uses a config file.

Handles file uploads.

Can listen on multiple ports.

Has basic CGI support.

🧠 PHASE 2: Understand HTTP
Read RFC 1945 (HTTP/1.0) and/or RFC 2616 (HTTP/1.1):

Learn how HTTP requests look (GET /index.html HTTP/1.1).

Understand headers, body, and responses.

Understand status codes (200 OK, 404 Not Found, etc.).

Learn how Content-Length and Transfer-Encoding work.

📁 PHASE 3: Configuration File Parsing
Accept a config file path as an argument.

Parse the file:

Get the ports to listen on.

Set the root folder for each port.

Set allowed methods (GET, POST, DELETE).

Map routes to folders.

Specify error pages.

Specify upload folders.

Think: INI or nginx-style config. Break into blocks: server, location, etc.

🔌 PHASE 4: Network Setup
1. Open sockets
For each configured port, create a socket using socket().

Bind it using bind().

Set it to non-blocking with fcntl(fd, O_NONBLOCK).

Start listening with listen().

2. Poll Setup
Add all listening sockets to a pollfd array.

Keep this array updated with clients.

🧏 PHASE 5: Event Loop
Main Loop
Use poll() (or select() / epoll() / kqueue()):

Wait for activity on:

Server sockets (new connections).

Client sockets (read/write readiness).

Accepting Connections
If a listening socket is readable:

Accept client with accept().

Set client socket to non-blocking.

Add to poll list.

📡 PHASE 6: Request Parsing
Read Requests
If client socket is readable:

Use recv() to read.

Accumulate data until full request received.

Parse HTTP request:

Method

Path

Headers

Body (if POST/PUT)

Validate
Check headers (Content-Length, Host, etc.).

Enforce allowed methods.

Validate paths (prevent directory traversal, e.g., ../).

📦 PHASE 7: Response Handling
Based on Method:
GET:

Locate file.

Read it.

Send 200 or 404, etc.

POST:

Save data to upload directory.

Or run CGI if configured.

Respond with 201 or 204.

DELETE:

Remove file if exists.

Return 200 or 404.

Build Response:
Status line: HTTP/1.1 200 OK

Headers: Content-Length, Content-Type, etc.

Body: file content, error message, etc.

💬 PHASE 8: Sending Response
Wait for socket to be writeable.

Use send() in non-blocking mode.

Track how much you sent (if partial).

Close client (or keep-alive if HTTP/1.1).

🗑 PHASE 9: Timeout & Cleanup
If a client hasn't completed a request in N seconds:

Close it.

After sending response, remove client from poll list and close FD.

🧪 PHASE 10: Testing and Debugging
Use telnet to send raw requests.

Use curl to test POST/DELETE.

Compare behavior with NGINX.

Use stress tools like ab (ApacheBench) or wrk.

🧬 PHASE 11: CGI Support (Only part with fork())
Detect CGI file via path extension or config.

Fork a process.

Setup pipes for input/output.

Execute CGI with execve().

Send environment variables (CONTENT_LENGTH, QUERY_STRING, etc.).

Collect response from CGI output and forward to client.

📚 Important Notes
Only one poll() or select() or equivalent call per loop.

Don’t use blocking I/O.

Don’t check errno after read/write.

Use default error pages if none provided.

You can’t execve() another web server, only CGI scripts.

🔁 SUMMARY CHECKLIST
Feature	Status
Config file parsing	🔲
Multiple sockets	🔲
poll()/select() loop	🔲
Request parsing	🔲
Response building	🔲
GET/POST/DELETE	🔲
File upload	🔲
Error pages	🔲
CGI with fork/execve	🔲
HTTP 1.0/1.1 compliance	🔲
Non-blocking I/O	🔲
Stress-test support	🔲

Let me know which part you'd like help focusing on first—like config parser, request parsing logic, or CGI support—and I can guide you through it.


Yes, exactly! Let's walk through the practical implementation steps, in a small, focused way.

✅ Goal for First Steps
✅ Make a config file (with a port)
✅ Parse the config file
✅ Start a server socket on that port
✅ Use poll() to listen and accept new connections
✅ When a client connects (e.g., using telnet), print something

🪜 Step-by-Step Plan
1. Create a config file
Create a simple config file: server.conf

c
Copy
Edit
port 8080
2. In your main() function
✅ Step 1: Read the config file
Open the file using open() or C++98 ifstream.

Read the port number from it and store it (e.g., 8080).

✅ Step 2: Create a server socket
socket() → Create a TCP socket.

fcntl() → Set the socket to non-blocking.

bind() → Bind the socket to port 8080.

listen() → Start listening for incoming connections.

✅ Step 3: Set up poll()
Create a pollfd array.

Add your server socket to it.

Call poll() in a loop.

✅ Step 4: Accept client connections
If poll() shows the server socket is readable:

Use accept() to accept the connection.

Set the new client socket to non-blocking.

Add the client to the pollfd array.

✅ Step 5: Read from client
If a client socket is readable:

Use recv() to read.

For now, just print the request data (or partial data).

✅ Step 6: Respond
(Optional in first version): Send a simple HTTP response like:

http
Copy
Edit
HTTP/1.1 200 OK
Content-Length: 13
Content-Type: text/plain

Hello, world!
Use send() in non-blocking mode.

🧪 Step 7: Test it
From your terminal:

bash
Copy
Edit
$ ./webserv server.conf
In another terminal:

bash
Copy
Edit
$ telnet localhost 8080
GET / HTTP/1.1
Host: localhost

You should see the request printed in your server’s output.

🧱 Build it in layers
Start with just:

config reading ✔️

socket setup ✔️

poll + accept ✔️

recv + print ✔️

Then layer:

response sending

request parsing

multiple ports

POST/DELETE

CGI

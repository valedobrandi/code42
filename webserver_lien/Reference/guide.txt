To implement an HTTP server in C++98 as described, without code, here's a detailed, micro-level breakdown of the steps to help you understand the project structure and move forward step-by-step.

ğŸš¦ PHASE 1: Understand the Goal
Your goal is to implement a fully working HTTP/1.0+ web server in C++98 that:

Accepts multiple clients.

Handles GET, POST, and DELETE.

Uses non-blocking I/O (poll/select/epoll/kqueue).

Uses a config file.

Handles file uploads.

Can listen on multiple ports.

Has basic CGI support.

ğŸ§  PHASE 2: Understand HTTP
Read RFC 1945 (HTTP/1.0) and/or RFC 2616 (HTTP/1.1):

Learn how HTTP requests look (GET /index.html HTTP/1.1).

Understand headers, body, and responses.

Understand status codes (200 OK, 404 Not Found, etc.).

Learn how Content-Length and Transfer-Encoding work.

ğŸ“ PHASE 3: Configuration File Parsing
Accept a config file path as an argument.

Parse the file:

Get the ports to listen on.

Set the root folder for each port.

Set allowed methods (GET, POST, DELETE).

Map routes to folders.

Specify error pages.

Specify upload folders.

Think: INI or nginx-style config. Break into blocks: server, location, etc.

ğŸ”Œ PHASE 4: Network Setup
1. Open sockets
For each configured port, create a socket using socket().

Bind it using bind().

Set it to non-blocking with fcntl(fd, O_NONBLOCK).

Start listening with listen().

2. Poll Setup
Add all listening sockets to a pollfd array.

Keep this array updated with clients.

ğŸ§ PHASE 5: Event Loop
Main Loop
Use poll() (or select() / epoll() / kqueue()):

Wait for activity on:

Server sockets (new connections).

Client sockets (read/write readiness).

Accepting Connections
If a listening socket is readable:

Accept client with accept().

Set client socket to non-blocking.

Add to poll list.

ğŸ“¡ PHASE 6: Request Parsing
Read Requests
If client socket is readable:

Use recv() to read.

Accumulate data until full request received.

Parse HTTP request:

Method

Path

Headers

Body (if POST/PUT)

Validate
Check headers (Content-Length, Host, etc.).

Enforce allowed methods.

Validate paths (prevent directory traversal, e.g., ../).

ğŸ“¦ PHASE 7: Response Handling
Based on Method:
GET:

Locate file.

Read it.

Send 200 or 404, etc.

POST:

Save data to upload directory.

Or run CGI if configured.

Respond with 201 or 204.

DELETE:

Remove file if exists.

Return 200 or 404.

Build Response:
Status line: HTTP/1.1 200 OK

Headers: Content-Length, Content-Type, etc.

Body: file content, error message, etc.

ğŸ’¬ PHASE 8: Sending Response
Wait for socket to be writeable.

Use send() in non-blocking mode.

Track how much you sent (if partial).

Close client (or keep-alive if HTTP/1.1).

ğŸ—‘ PHASE 9: Timeout & Cleanup
If a client hasn't completed a request in N seconds:

Close it.

After sending response, remove client from poll list and close FD.

ğŸ§ª PHASE 10: Testing and Debugging
Use telnet to send raw requests.

Use curl to test POST/DELETE.

Compare behavior with NGINX.

Use stress tools like ab (ApacheBench) or wrk.

ğŸ§¬ PHASE 11: CGI Support (Only part with fork())
Detect CGI file via path extension or config.

Fork a process.

Setup pipes for input/output.

Execute CGI with execve().

Send environment variables (CONTENT_LENGTH, QUERY_STRING, etc.).

Collect response from CGI output and forward to client.

ğŸ“š Important Notes
Only one poll() or select() or equivalent call per loop.

Donâ€™t use blocking I/O.

Donâ€™t check errno after read/write.

Use default error pages if none provided.

You canâ€™t execve() another web server, only CGI scripts.

ğŸ” SUMMARY CHECKLIST
Feature	Status
Config file parsing	ğŸ”²
Multiple sockets	ğŸ”²
poll()/select() loop	ğŸ”²
Request parsing	ğŸ”²
Response building	ğŸ”²
GET/POST/DELETE	ğŸ”²
File upload	ğŸ”²
Error pages	ğŸ”²
CGI with fork/execve	ğŸ”²
HTTP 1.0/1.1 compliance	ğŸ”²
Non-blocking I/O	ğŸ”²
Stress-test support	ğŸ”²

Let me know which part you'd like help focusing on firstâ€”like config parser, request parsing logic, or CGI supportâ€”and I can guide you through it.


Yes, exactly! Let's walk through the practical implementation steps, in a small, focused way.

âœ… Goal for First Steps
âœ… Make a config file (with a port)
âœ… Parse the config file
âœ… Start a server socket on that port
âœ… Use poll() to listen and accept new connections
âœ… When a client connects (e.g., using telnet), print something

ğŸªœ Step-by-Step Plan
1. Create a config file
Create a simple config file: server.conf

c
Copy
Edit
port 8080
2. In your main() function
âœ… Step 1: Read the config file
Open the file using open() or C++98 ifstream.

Read the port number from it and store it (e.g., 8080).

âœ… Step 2: Create a server socket
socket() â†’ Create a TCP socket.

fcntl() â†’ Set the socket to non-blocking.

bind() â†’ Bind the socket to port 8080.

listen() â†’ Start listening for incoming connections.

âœ… Step 3: Set up poll()
Create a pollfd array.

Add your server socket to it.

Call poll() in a loop.

âœ… Step 4: Accept client connections
If poll() shows the server socket is readable:

Use accept() to accept the connection.

Set the new client socket to non-blocking.

Add the client to the pollfd array.

âœ… Step 5: Read from client
If a client socket is readable:

Use recv() to read.

For now, just print the request data (or partial data).

âœ… Step 6: Respond
(Optional in first version): Send a simple HTTP response like:

http
Copy
Edit
HTTP/1.1 200 OK
Content-Length: 13
Content-Type: text/plain

Hello, world!
Use send() in non-blocking mode.

ğŸ§ª Step 7: Test it
From your terminal:

bash
Copy
Edit
$ ./webserv server.conf
In another terminal:

bash
Copy
Edit
$ telnet localhost 8080
GET / HTTP/1.1
Host: localhost

You should see the request printed in your serverâ€™s output.

ğŸ§± Build it in layers
Start with just:

config reading âœ”ï¸

socket setup âœ”ï¸

poll + accept âœ”ï¸

recv + print âœ”ï¸

Then layer:

response sending

request parsing

multiple ports

POST/DELETE

CGI

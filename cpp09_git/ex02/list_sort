#include <list>
#include <deque>
#include <algorithm>

void ford_algorithm_list(std::list<int> &container) {
    size_t n = container.size();

    // Base cases
    if (n <= 1) return;
    if (n == 2) {
        auto it = container.begin();
        auto next_it = std::next(it);
        if (*it > *next_it)
            std::swap(*it, *next_it);
        return;
    }

    std::list<int> winners;
    std::list<int> losers;

    auto it = container.begin();
    while (std::next(it) != container.end()) {
        auto next_it = std::next(it);
        if (*it > *next_it) {
            winners.push_back(*it);
            losers.push_back(*next_it);
        } else {
            winners.push_back(*next_it);
            losers.push_back(*it);
        }
        std::advance(it, 2);
    }

    // Handle leftover
    if (it != container.end()) {
        winners.push_back(*it);
    }

    // Recursively sort winners
    ford_algorithm_list(winners);

    // Clear original container
    container.clear();

    // Insert losers in Jacobsthal order
    std::deque<int> jacob_seq = jacobs_index(losers.size());
    for (int idx : jacob_seq) {
        if (idx >= (int)losers.size()) continue;

        // Get iterator to B[idx]
        auto b_it = losers.begin();
        std::advance(b_it, idx);

        // Find insertion position in winners
        auto pos = winners.begin();
        for (; pos != winners.end(); ++pos) {
            if (*pos >= *b_it) break;
        }

        winners.insert(pos, *b_it);
    }

    // Move sorted winners back to container efficiently
    container.splice(container.begin(), winners);
}

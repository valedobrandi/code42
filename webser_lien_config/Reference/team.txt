1. Launch Server
🔧 What it means:
Parse the configuration file.

Create and configure all listening sockets.

Initialize internal state (routes, error pages, port bindings, etc.)

🎯 Responsibilities:
config_parser.cpp: parse config into objects

server_manager.cpp: create socket(), bind(), listen() on all ports

Set file descriptors to non-blocking

🔄 Input:
CLI arg: ./webserv config.conf

Output:

Listening socket FDs

Server config structure

✅ 2. Listen & Accept Clients
🔧 What it means:
Use poll() (or select()) to monitor all server and client sockets

Accept new connections when poll says a listening socket is ready

🎯 Responsibilities:
poll_loop.cpp: manage FD list, call poll()

connection_manager.cpp: create a new connection object for each client

Each client gets a Connection class instance with state tracking

🔄 Input:
List of sockets to monitor

Output:

FD events (readable, writable)

New connection objects

✅ 3. Receive Request (Read & Parse)
🔧 What it means:
Read data from client socket when poll() says it's readable

Assemble full HTTP request (handle partial reads)

Parse method, URI, headers, and body

🎯 Responsibilities:
connection.cpp: per-client state, read buffer

http_parser.cpp: builds Request objects from raw bytes

Handle Content-Length, chunked encoding, etc.

🔄 Input:
Raw socket buffer from recv()

Output:

Parsed Request object (method, path, headers, body)

Transition connection state to "ready to respond"

✅ 4. Respond to Client
🔧 What it means:
Based on Request, generate a matching HTTP response

Serve static file, delete file, handle upload, or return error

Write response when socket is writable

🎯 Responsibilities:
router.cpp: decide what handler to run (GET/POST/DELETE)

response_builder.cpp: generate headers + body

connection.cpp: write to client with send()

🔄 Input:
Parsed Request

Config info (routes, allowed methods)

Output:

Raw HTTP response string

Written to socket (in chunks if necessary)

✅ Optional Phase 5: Cleanup
Close sockets when finished

Clean up file uploads (if temporary)

Log request/response



✅ 1. LAUNCH – Config Parsing & Socket Setup
🎯 Goal:
Verify that:

Your config parser loads valid settings.

A listening socket is created on the correct port.

🔬 Minimal test:
Input:

bash
Copy
Edit
./webserv config/basic.conf
Contents of basic.conf:

nginx
Copy
Edit
server {
    listen 8080;
    root ./www;
}
Expected behavior:

Console prints: Listening on port 8080

Use this to verify:

bash
Copy
Edit
netstat -an | grep 8080
or:

bash
Copy
Edit
lsof -i :8080
Failure signs:

Bind errors (port in use)

No message printed

No socket open

✅ 2. LISTEN – Accept Connections (Poll loop works)
🎯 Goal:
Confirm that your server accepts connections and doesn’t block.

No data exchange yet — just accept and close.

🔬 Minimal test:
Run:

bash
Copy
Edit
./webserv config/basic.conf
In another terminal:

bash
Copy
Edit
telnet localhost 8080
Server should accept, print:

pgsql
Copy
Edit
New connection from 127.0.0.1
and then close (if no recv() yet)

Failure signs:

Server hangs

Connection refused

Nothing printed after telnet connects

✅ 3. RECEIVE – Read HTTP Request
🎯 Goal:
Confirm server can read data from client after connection.

Parse a very basic HTTP request (GET / HTTP/1.1)

🔬 Minimal test:
Run server with a config that allows /

From client:

bash
Copy
Edit
printf "GET / HTTP/1.1\r\nHost: localhost\r\n\r\n" | nc localhost 8080
Server should print:

vbnet
Copy
Edit
Method: GET
Path: /
Version: HTTP/1.1
Or log the parsed request fields.

Failure signs:

Server hangs on recv() (didn’t use poll)

Incomplete request

Crash or segfault

✅ 4. RESPOND – Return Basic HTTP Response
🎯 Goal:
Send a valid HTTP 200 OK response for GET /

🔬 Minimal test:
Use the same nc or telnet command from step 3.

Server response:

makefile
Copy
Edit
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 12

Hello World!
Client output:
You should see that entire block printed.

Failure signs:

Client sees nothing or gets disconnected

Wrong status line

Extra characters (missing Content-Length or CRLF)

🧪 BONUS: POST Test (upload)
🎯 Goal:
Confirm server reads a body and stores it

Command:

bash
Copy
Edit
curl -X POST -d "foo=bar" http://localhost:8080/upload
Expected:

Server logs the body: foo=bar

Creates a file with that content if implemented

✅ Summary Table of Minimal Tests
Phase	Test Input	Expected Output
Launch	./webserv config.conf	"Listening on port 8080"
Listen	telnet localhost 8080	"New connection from ..."
Receive	GET / HTTP/1.1\r\nHost: ... (via nc)	Parsed method, path, headers printed
Respond	Same as above	HTTP response with body "Hello World!"
Upload	curl -X POST -d ...	Server logs POST body or saves it

What does it mean?
Your server must remain non-blocking at all times and properly handle client disconnections when necessary.

This requirement has two parts:

Non-blocking at all times

Properly handle client disconnects

🚫 What you can't do:
You can't use blocking system calls like read() or recv() on a socket unless poll() (or equivalent) told you that the socket is ready.

You can’t loop or sleep waiting for something to happen on a socket.

You can’t use blocking accept() without ensuring it’s ready.

You can’t ignore client disconnections, like a client closing the tab.

✅ What you must do:
🟢 1. Make all sockets non-blocking
For every socket (server and clients):

cpp
Copy
Edit
fcntl(fd, F_SETFL, O_NONBLOCK);
🟢 2. Use poll() (or select/kqueue/epoll)
Only call read() / recv() if poll() reports POLLIN.

Only call write() / send() if poll() reports POLLOUT.

Do not read or write outside poll()-reported readiness.

🟢 3. Detect client disconnection
If recv() returns:

0: the client closed the connection gracefully.

< 0: check errno. If it’s EAGAIN or EWOULDBLOCK, ignore. Otherwise, treat as error.

You must close the socket and remove it from your poll list when a client disconnects.

🧠 Why it matters
Blocking calls can freeze your whole server when one client misbehaves.

Not handling disconnects will cause:

Memory leaks

FD leaks (too many open files)

Server eventually crashes or hangs

✅ How to test this requirement
1. Non-blocking behavior test
Connect multiple clients with telnet, send part of a request, then wait.

If the server still accepts other clients, it's non-blocking.

2. Disconnection handling
Connect with telnet, then close the window.

The server should detect this, close the socket, and clean up without error or hang.

2. Single poll() Call for All I/O (Server + Clients, Non-Blocking)
🔍 What does it mean?
Your server must:

Use only one poll() (or select(), epoll(), kqueue()) for all I/O:

Listening sockets (accept())

Client sockets (reading requests, writing responses)

That includes:

Accepting new connections

Receiving client data

Sending data back to clients

🚫 What you cannot do:
❌ Use more than one poll() call (e.g., one for read, another for write)

❌ Use recv() or send() without poll() saying the socket is ready

❌ Use blocking I/O anywhere in your client or server loop

✅ What you must do:
1. Set all FDs (sockets) to non-blocking
cpp
Copy
Edit
fcntl(fd, F_SETFL, O_NONBLOCK);
2. Maintain a single list of pollfd structs
Add listening socket FDs

Add all connected client FDs

Set .events = POLLIN | POLLOUT as needed

3. Run a single poll() inside your event loop:
cpp
Copy
Edit
poll(pollfds, nfds, timeout);
pollfds: array of all monitored sockets

POLLIN: ready to read (new data from client or new connection)

POLLOUT: ready to write (client is ready to receive response)

🧪 How to test this requirement
✅ Single poll() behavior:

Add debug logs:

cpp
Copy
Edit
std::cout << "Polling on " << fds.size() << " sockets" << std::endl;
Add multiple clients (use telnet, curl, etc.), and observe:

Server never blocks

All clients are handled in the same loop

New connections and existing clients are served without delay

✅ Try mixing:

A slow client

A fast client

A reconnecting client

If everything remains smooth and responsive — your single poll() loop is working.

💡 Why this is important
Forces you to design a proper event-driven server.

Prevents blocking on one client while others wait.

Keeps everything efficient — just like NGINX or Node.js does under the hood.

3. poll() Must Monitor Both Reading and Writing Simultaneously
🔍 What does it mean?
When you add a file descriptor (FD) to the poll() list (or select(), epoll(), etc.), you must tell it to watch both:

POLLIN → when the socket is ready to read (e.g., client sent something)

POLLOUT → when the socket is ready to write (e.g., you can send a response)

This means your server must always be ready to:

Receive new data if the client sends more

Send buffered response data if the socket becomes writable

🧱 What this looks like in pollfd:
cpp
Copy
Edit
pollfd fd_entry;
fd_entry.fd = client_fd;
fd_entry.events = POLLIN | POLLOUT;  // both read and write
fds.push_back(fd_entry);
🚫 What you must not do:
❌ Only monitor POLLIN and then wait for writing

❌ Add POLLOUT only after preparing a response (reactively)

❌ Modify poll set too late, causing missed opportunities to write

❌ Use send() or write() without checking POLLOUT

✅ Correct usage pattern:
From the beginning of a client connection, monitor:

POLLIN: for incoming request

POLLOUT: for sending response (or partial writes)

This allows you to:

Read from the client when ready

Start writing responses as soon as the socket allows it — even if it needs multiple send() calls (chunked or large body)

🧠 Why both at the same time?
Because sockets are asynchronous streams:

A client might send a big POST body → needs to be read across many poll() cycles.

You might be building and sending a huge file → need to send it in chunks as POLLOUT becomes ready.

If you only monitor one direction, you risk:

Blocking the server logic

Missing client disconnections

Sending responses late

🧪 Minimal test: monitor read & write
Run your server

Connect with:

bash
Copy
Edit
curl http://localhost:8080/ --limit-rate 1b
(slows down client’s receiving side)

Your server should not hang.

It should:

Begin sending the response

Wait for socket to become writable again

Finish sending response eventually

If you only had POLLIN, you wouldn't be able to do this correctly.

✅ Your server must be compatible with standard web browsers
🔍 What does it mean?
Your web server must:

Respond to HTTP requests from real web browsers (like Chrome, Firefox, Safari, etc.)

Handle requests in the format browsers expect

Return valid HTTP responses browsers can parse and render

So if you go to http://localhost:8080 in a browser, it should load a page, not crash, hang, or return garbage.

🧠 Why it matters
Browser requests are stricter and more complex than telnet or curl:

They always include headers like Host, Connection, User-Agent, etc.

They expect well-formed responses:

Correct HTTP version (HTTP/1.1)

Status line

Required headers (like Content-Length, Content-Type)

Blank line

Body

If your server is even slightly out of spec, a browser may:

Show a blank page

Show "Connection reset"

Hang or time out

Try to download the response as a file

✅ Minimal Features for Browser Compatibility
To satisfy this requirement, your server must correctly support:

Feature	Why it's needed
HTTP/1.1 syntax	Modern browsers use HTTP/1.1 by default
Host header parsing	Required in HTTP/1.1 (even if you don’t implement virtual hosts)
Proper Content-Length	Browsers use it to know when response ends
Correct status line	e.g. HTTP/1.1 200 OK
Double CRLF after headers	Must be \r\n\r\n, not just \n\n
UTF-8 or correct MIME types	So browser knows how to render text or images
Default route (e.g. /)	Visiting http://localhost:8080 hits /
Connection: close or keep-alive	Depending on your design, send correct connection handling info

✅ Minimal Browser Compatibility Test
Run your server with:

bash
Copy
Edit
./webserv config/basic.conf
In your browser:

Visit: http://localhost:8080/

You should see:

An HTML page (or plain text)

Correct page content

No error or download popup

Open Dev Tools → Network tab:

Check the request and response headers

Verify status is 200 OK

Check if Content-Length, Content-Type look good

🔧 Example of a valid HTTP response:
pgsql
Copy
Edit
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 25
Connection: close

<h1>Hello Browser</h1>
🔬 Test Scenarios You Should Try:
✅ http://localhost:8080/ (serving index.html)

✅ http://localhost:8080/image.jpg (serve an image)

✅ http://localhost:8080/not-found → return 404

✅ Form POST via browser

✅ Upload file via HTML form

✅ Reload page, test keep-alive or Connection: close

✅ Test DELETE via JS fetch() call
 When you CAN use fork() — for CGI
When a browser/client requests a CGI resource, e.g.:

h
Copy
Edit
GET /script.py HTTP/1.1
You must:

Detect that it's a CGI file

fork() a child process

In the child:

Set environment variables (e.g. REQUEST_METHOD, QUERY_STRING)

Use dup2() to redirect stdin/stdout to pipe

execve() the CGI program (Python, PHP, etc.)

In the parent:

Read from pipe (stdout of script)

Send it back to the client as HTTP response

This is the only place fork is allowed.

❌ What NOT to do
You cannot:

fork() on every accept()

Use fork() to handle multiple clients simultaneously

Spawn separate processes to read/write files

Use system() (which implicitly calls fork())

✅ TL;DR Summary
✅ Do	❌ Don’t
Use fork() for CGI only	fork() per connection or thread
Use execve() after fork	system() (uses fork internally)
Use pipes to read CGI output	Use fork to isolate blocking I/O
Handle most logic in poll()	Use fork for concurrency

✅ How to test this requirement
Test 1: Forbidden fork()
Run strace ./webserv (on Linux)

Connect to server

✅ You should not see fork() called unless CGI is triggered

Test 2: CGI fork
Request a CGI script (like /hello.py)

✅ You should see:

fork() → execve() → script output sent

Would you like a high-level breakdown of how to implement the CGI pipeline safely using fork/execve and pipes?

That lets the other person start coding:
✅ parseRequest()
Parse GET /index.html HTTP/1.1

Parse headers like Host, Content-Length, etc.

✅ handleRequest()
Based on method + path:

Serve file (GET)

Handle upload (POST)

Delete file (DELETE)

Return 404 or 405 if not allowed

✅ buildResponse()
Create proper HTTP response:

Status line: HTTP/1.1 200 OK

Headers: Content-Length, Content-Type

Body: file contents or message